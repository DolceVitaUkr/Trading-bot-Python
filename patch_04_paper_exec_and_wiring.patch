*** Begin Patch
*** Add File: tradingbot/core/paper_execution.py
+import random, time
+from typing import Dict, Any, Optional
+from .loggerconfig import get_logger
+
+log = get_logger(__name__)
+
+class PaperExecutionModel:
+    def __init__(self, slippage_bps: int = 8, partial_prob: float = 0.2, min_latency_ms: int = 100, max_latency_ms: int = 300):
+        self.slippage_bps = slippage_bps
+        self.partial_prob = partial_prob
+        self.min_latency_ms = min_latency_ms
+        self.max_latency_ms = max_latency_ms
+
+    async def execute(self, symbol: str, side: str, qty: float, price: Optional[float], **extra) -> Dict[str, Any]:
+        delay = random.randint(self.min_latency_ms, self.max_latency_ms) / 1000.0
+        time.sleep(delay)
+        p = float(price) if price is not None else float(extra.get('last', 0))
+        if p <= 0:
+            raise ValueError("PaperExecutionModel requires a positive price or last quote")
+        slip = p * (self.slippage_bps / 10000.0)
+        filled_price = p + slip if side.lower() == "buy" else p - slip
+        filled_qty = qty
+        status = "FILLED"
+        if random.random() < self.partial_prob:
+            filled_qty = max(qty * random.uniform(0.4, 0.9), 0.0)
+            status = "PARTIAL"
+        return {
+            "symbol": symbol,
+            "side": side,
+            "avg_price": round(filled_price, 8),
+            "filled_qty": round(filled_qty, 8),
+            "status": status,
+            "latency_s": delay,
+            "slippage_bps": self.slippage_bps
+        }
+
*** End Patch
*** Begin Patch
*** Add File: tradingbot/core/order_events.py
+import json, time
+from pathlib import Path
+from typing import Dict, Any
+from .loggerconfig import get_logger
+log = get_logger(__name__)
+def _append_jsonl(path: Path, row: Dict[str, Any]) -> None:
+    path.parent.mkdir(parents=True, exist_ok=True)
+    with open(path, "a", encoding="utf-8") as f:
+        f.write(json.dumps(row, default=str) + "\n")
+def emit_event(base_dir: Path, mode: str, asset: str, event: Dict[str, Any]) -> None:
+    ts = time.strftime("%Y-%m-%dT%H:%M:%S")
+    row = {"ts": ts, "mode": mode, "asset": asset, **event}
+    if mode == "paper":
+        path = base_dir / "state" / "paper" / f"trades_{asset}.jsonl"
+    else:
+        venue = event.get("venue", "live")
+        path = base_dir / "state" / "live" / venue / f"trades_{asset}.jsonl"
+    _append_jsonl(path, row)
+
*** End Patch
*** Begin Patch
*** Update File: tradingbot/core/paper_trader.py
@@
+from .paper_execution import PaperExecutionModel
+_exec_model = PaperExecutionModel()
+async def submit_order(symbol: str, side: str, qty: float, price: float | None, **extra):
+    return await _exec_model.execute(symbol, side, qty, price, **extra)
+
*** End Patch
*** Begin Patch
*** Update File: tradingbot/core/trading_engine.py
@@
+from .routing import PaperRouter, LiveRouter, OrderContext
+from .paper_sim_wrapper import simulate_with_paper_trader
+from .live_adapters import bybit_submit_wrapper, ibkr_submit_wrapper
+
+def _build_routers(paper_trader, bybit_adapter=None, ibkr_adapter=None):
+    paper = PaperRouter(lambda oc: simulate_with_paper_trader(paper_trader, oc))
+    submitters = {}
+    if bybit_adapter is not None:
+        submitters['bybit'] = lambda oc: bybit_submit_wrapper(bybit_adapter, oc)
+    if ibkr_adapter is not None:
+        submitters['ibkr'] = lambda oc: ibkr_submit_wrapper(ibkr_adapter, oc)
+    live = LiveRouter(submitters)
+    return paper, live
+
*** End Patch
